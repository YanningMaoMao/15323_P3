# File : server.srp
# Author : Yanning Mao (yanningm)
# Date : March 2, 2018
# Course : CMU 15-323 S18
#
# Description:
# 
# This file is a real-time program that outputs music using MIDI and generates
# corresponding image on the Canvas.
#
# --- Music Generation ---
# The music has four sound tracks, each with a different sound effect and a
# different set of pitches that will be played by that track. While playing,
# the track decides which pitch to play by randomly picking one pitch from the
# set of pitches belonging to it.
# Each track also has its own randomly generated rhythm. The rhythm is a cycle
# of 16 notes. The rhythm is generated by randomly deciding whether to play
# each of the 16 notes with probability half and half.
#
# --- Image Generation ---
# The program also generates image together with the music. For each track,
# there is a line representing the note being played. The height of the line
# corresponds to the pitch, and the color of the line corresponds to the
# volume. When the pitch is higher, the line jumps higher. When the volume is
# larger, the line becomes more red; when the volume is lower, the line becomes
# more yellow.
#
# --- Features ---
# For controlling the whole music, there is
# + a slider that controls the tempo
# + a start all button that starts all tracks
# + a stop all button that stops all tracks
# For controlling each track, there is
# + a slider that controls the volume of the track
# + a stop button that stops the track
# + a start button that starts the track
# + an octave up button that raises all pitches of the track by one octave
# + an octave down button that lowers all pitches of the track by one octave
#

require "choir"
require "canvas"
require "constants"
require "debug"
require "wxserpent"


class Server:

	var choir

	def init():
		# sched_o2_enabled = true
		init_project()
		install_handlers()
		init_osc()

	def run():
	    while true
	        o2_poll()
	        time_sleep(0.01)
			
	# make a full path with SERVICE prefix
	def full(osc_path):
	    # make a full O2 path based on SERVICE
	    return "/" + SERVER_SERVICE + osc_path

	def install_handlers_for_choir():
	    # the button that stops all sound tracks
	    o2_method_new(full("/cmsip/stopAllButton"), "f",
	    				'stop_all_button_handler', true)
	    # the button that starts all sound tracks
	    o2_method_new(full("/cmsip/startAllButton"), "f",
	    				'start_all_button_handler', true)
	    # the slider that controls the period
	    o2_method_new(full("/cmsip/periodSlider"), "f",
	    				'period_slider_handler', true)
	    return


	def install_handlers_for_track_one():
	    # the button that stops the sound track
	    o2_method_new(full("/cmsip/stopTrackOneButton"), "f",
	    				'stop_track_one_handler', true)
	    # the button that raises the octave of the sound track
	    o2_method_new(full("/cmsip/octaveUpTrackOneButton"), "f",
	    				'octave_up_track_one_button_handler', true)
	    # the button that lowers the octave of the sound track
	    o2_method_new(full("/cmsip/octaveDownTrackOneButton"), "f",
	    				'octave_down_track_one_button_handler', true)
	    # the button that starts the sound track
	    o2_method_new(full("/cmsip/startTrackOneButton"), "f",
	    				'start_track_one_handler', true)
	    # the slider that controls the volume of the track
	    o2_method_new(full("/cmsip/velocityTrackOneSlider"), "f",
	    				'velocity_track_one_slider_handler', true)
	    return


	def install_handlers_for_track_two():
		# the button that stops the sound track
	    o2_method_new(full("/cmsip/stopTrackTwoButton"), "f",
	    				'stop_track_two_handler', true)
	    # the button that raises the octave of the sound track
	    o2_method_new(full("/cmsip/octaveUpTrackTwoButton"), "f",
	    				'octave_up_track_two_button_handler', true)
	    # the button that lowers the octave of the sound track
	    o2_method_new(full("/cmsip/octaveDownTrackTwoButton"), "f",
	    				'octave_down_track_two_button_handler', true)
	    # the button that starts the sound track
	    o2_method_new(full("/cmsip/startTrackTwoButton"), "f",
	    				'start_track_two_handler', true)
	    # the slider that controls the volume of the track
	    o2_method_new(full("/cmsip/velocityTrackTwoSlider"), "f",
	    				'velocity_track_two_slider_handler', true)
	    return


	def install_handlers_for_track_three():
	    # the button that stops the sound track
	    o2_method_new(full("/cmsip/stopTrackThreeButton"), "f",
	    				'stop_track_three_handler', true)
	    # the button that raises the octave of the sound track
	    o2_method_new(full("/cmsip/octaveUpTrackThreeButton"), "f",
	    				'octave_up_track_three_button_handler', true)
	    # the button that lowers the octave of the sound track
	    o2_method_new(full("/cmsip/octaveDownTrackThreeButton"), "f",
	    				'octave_down_track_three_button_handler', true)
	    # the button that starts the sound track
	    o2_method_new(full("/cmsip/startTrackTwoButton"), "f",
	    				'start_track_three_handler', true)
	    # the slider that controls the volume of the track
	    o2_method_new(full("/cmsip/velocityTrackThreeSlider"), "f",
	    				'velocity_track_three_slider_handler', true)
	    return


	def install_handlers_for_track_four():
	    # the button that stops the sound track
	    o2_method_new(full("/cmsip/stopTrackFourButton"), "f",
	    				'stop_track_four_handler', true)
	    # the button that raises the octave of the sound track
	    o2_method_new(full("/cmsip/octaveUpTrackFourButton"), "f",
	    				'octave_up_track_four_button_handler', true)
	    # the button that lowers the octave of the sound track
	    o2_method_new(full("/cmsip/octaveDownTrackFourButton"), "f",
	    				'octave_down_track_four_button_handler', true)
	    # the button that starts the sound track
	    o2_method_new(full("/cmsip/startTrackFourButton"), "f",
	    				'start_track_four_handler', true)
	    # the slider that controls the volume of the track
	    o2_method_new(full("/cmsip/velocityTrackFourSlider"), "f",
	    				'velocity_track_four_slider_handler', true)
	    return

	def install_handlers_for_tracks():
	    # the button that stops the sound track
	    o2_method_new(full("/cmsip/stopTrackButton"), "f",
	    				'stop_track_handler', true)
	    # the button that starts the sound track
	    o2_method_new(full("/cmsip/startTrackButton"), "f",
	    				'start_track_handler', true)
	    # the button that raises the octave of the sound track
	    o2_method_new(full("/cmsip/octaveUpTrackButton"), "f",
	    				'octave_up_track_button_handler', true)
	    # the button that lowers the octave of the sound track
	    o2_method_new(full("/cmsip/octaveDownTrackButton"), "f",
	    				'octave_down_track_button_handler', true)
	    # the slider that controls the volume of the track
	    o2_method_new(full("/cmsip/velocityTrackSlider"), "f",
	    				'velocity_track_slider_handler', true)
	    return

	def install_handlers():
	    print "Installing handlers ..."
	    # handlers for Choir
	    install_handlers_for_choir()
	    # handlers for Tracks
	    install_handlers_for_tracks()

	def stop_all_button_handler(timestamp, address, types, val):
		choir.stop_all()
		return

	def start_all_button_handler(timestamp, address, types, val):
		choir.start_all()
		return

	def period_slider_handler(timestamp, address, types, val):
		choir.set_period()
		return

	def stop_track_handler(timestamp, address, types, val):
		track_idx = (int)(val - 1)
		choir.tracks[track_idx].stop()
		return

	def start_track_handler(timestamp, address, types, val):
		track_idx = (int)(val - 1)
		choir.tracks[track_idx].start()
		return

	def octave_up_track_button_handler(timestamp, address, types, val):
		track_idx = (int)(val - 1)
		choir.tracks[track_idx].octave_up()
		return

	def octave_down_track_button_handler(timestamp, address, types, val):
		track_idx = (int)(val - 1)
		choir.tracks[track_idx].octave_down()
		return

	def velocity_track_slider_handler(timestamp, address, types, val):
		track_idx = (int)(val[0] - 1)
		new_vel = (int)val[1]
		choir.tracks[track_idx].set_velocity(new_vel)
		return

	# sets up the window, initiates the scheduler, then starts the music and
	# the animation
	def init_project():

	    # initialize the scheduler
	    sched_init()

	    # open midi output
	    prefs = Prefs("./prefs.txt")
	    midi_devices = Midi_devices(prefs, open_later = true)
	    success = midi_devices.open_midi(latency = 10, device = 'midi_out_device')

	    # check output device
	    if not success
	        print "PLEASE SELECT A VALID OUTPUT DEVICE AND RESTART THIS PROGRAM"
	        return

	    # sets the frame
	    default_window.set_size(window_width, window_height)

	    # initializes the music
	    choir = Choir()
	    # initializes the canvas
	    p2Canvas = MusicCanvas(default_window, canvas_margin, canvas_margin,
	                            canvas_width, canvas_height)
	    p2Canvas.take_plugin(choir)

	    sched_select(vtsched)
	    sched_set_period(choir.period_slider.value())
	    # starts the music
	    sched_cause(real_delay(5),
	                choir.track_one, 'play', 0, choir.track_one.curr_pitch)
	    sched_cause(real_delay(5),
	                choir.track_two, 'play', 0, choir.track_two.curr_pitch)
	    sched_cause(real_delay(5),
	                choir.track_three, 'play', 0, choir.track_three.curr_pitch)
	    sched_cause(real_delay(5),
	                choir.track_four, 'play', 0, choir.track_four.curr_pitch)
	    # starts the animation
	    sched_cause(real_delay(5), p2Canvas, 'animate')

	def init_osc():

		# initialize the OSC
	    o2_initialize(APPLICATION, false)
	    o2_service_new(SERVER_SERVICE)
	    o2_clock_set()

		# use the input port number if given
		if len(command_line_arguments) > 1 and isdigit(command_line_arguments[1])
			osc_port = int(command_line_arguments[1])

		# open the port 
		rslt = o2_osc_port_new(SERVER_SERVICE, osc_port, false)
		if rslt != 0
			print "OSC Server failed to open port on ", osc_port
		else
			print "OSC Server listening for OSC messages on port ", osc_port

		return


server = Server()
server.run()
