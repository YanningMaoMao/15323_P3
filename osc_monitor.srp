# osc_monitor.srp -- a test program to receive from donttouchosc.srp and
#                    other OSC sources
#
# Gus Xia and Roger Dannenberg
# Feb 14, 2014
# modified for O2, Feb 2017

# run this with serpent64 (not wxserpent)
#
# this program demostrates receiving OSC messages from a client,
# specifically the wxserpent program donttouchosc.srp.
#
# To see donttouchosc.srp messages, run like this on the command line:
#    serpent64 osc_monitor d
# To see ALL osc messages, run like this on the command line:
#    serpent64 osc_monitor [port-number]
# where port-number is an optional decimal integer

require "debug"
require "canvas"
require "constants"
require "choir"

# This is the O2 application name. Only O2 processes with the same
# application name and same local area network can communicate, so
# we make the application name easy to change.
APPLICATION = "p3"

# Similarly, we make the service name easy to change here so that
# this program can be modified to offer any O2 service. Note that
# service names are assumed to be unique, so if you try to "snoop"
# on messages to another service, you may interfere with that service.
SERVICE = "p3"

# default port number that O2 listens on
osc_port = 8001

var choir

# make a full path with SERVICE prefix
def full(osc_path):
    # make a full O2 path based on SERVICE
    return "/" + SERVICE + osc_path

def install_donttouchosc_handlers():
    print "Installing handlers for donttouchosc.srp messages"
    o2_method_new(full("/cmsip/buttonA"), "f", 'buttonA', true)
    o2_method_new(full("/cmsip/buttonB"), "f", 'buttonB', true)
    o2_method_new(full("/cmsip/buttonC"), "f", 'buttonC', true)
    o2_method_new(full("/cmsip/buttonD"), "f", 'buttonD', true)
    o2_method_new(full("/cmsip/sliderA"), "f", 'sliderA', true)
    o2_method_new(full("/cmsip/sliderB"), "f", 'sliderB', true)
    o2_method_new(full("/cmsip/sliderC"), "f", 'sliderC', true)
    o2_method_new(full("/cmsip/sliderD"), "f", 'sliderD', true)
    o2_method_new(full("/cmsip/checkW"), "f", 'checkW', true)
    o2_method_new(full("/cmsip/checkX"), "f", 'checkX', true)
    o2_method_new(full("/cmsip/checkY"), "f", 'checkY', true)
    o2_method_new(full("/cmsip/checkZ"), "f", 'checkZ', true)
    o2_method_new(full("/cmsip/canvas"), "fff", 'canvas', true)

# handler functions for donttouchosc messages
def buttonA(timestamp, address, types, val):
    display "server button A", address, val
def buttonB(timestamp, address, types, val):
    display "server button B", address, val
def buttonC(timestamp, address, types, val):
    display "server button C", address, val    
def buttonD(timestamp, address, types, val):
    display "server button D", address, val
def sliderA(timestamp, address, types, val):
    display "server slider A", address, val
def sliderB(timestamp, address, types, val):
    display "server slider B", address, val
def sliderC(timestamp, address, types, val):
    display "server slider C", address, val    
def sliderD(timestamp, address, types, val):
    display "server slider D", address, val
def checkW(timestamp, address, types, val):
    display "server checkbox W", address, val
def checkX(timestamp, address, types, val):
    display "server checkbox X", address, val
def checkY(timestamp, address, types, val):
    display "server checkbox Y", address, val
def checkZ(timestamp, address, types, val):
    display "server checkbox Z", address, val
def canvas(timestamp, address, types, x, y, status):
    display "server canvas", address, x, y, status

def install_handlers():
    print "Installing handlers ..."
    # handlers for Choir
    install_handlers_for_choir()
    # handlers for Tracks
    install_handlers_for_tracks()

def install_handlers_for_choir():
    # the button that stops all sound tracks
    o2_method_new(full("/stopAllButton"), "f", 'stop_all_button_handler', true)
    # the button that starts all sound tracks
    o2_method_new(full("/startAllButton"), "f", 'start_all_button_handler', true)
    # the slider that controls the period
    o2_method_new(full("/periodSlider"), "f", 'period_slider_handler', true)

def install_handlers_for_tracks():
    for i = 0 to num_tracks:
        # the button that stops the sound track
        o2_method_new((full("/stopTrackButton") + "/" + str(i)), "f",
                                    'stop_track_handler', true)
        # the button that starts the sound track
        o2_method_new((full("/startTrackButton") + "/" + str(i)), "f",
                                    'start_track_handler', true)
        # the button that raises the octave of the sound track
        o2_method_new((full("/octaveUpTrackButton") + "/" + str(i)), "f",
                                    'octave_up_track_button_handler', true)
        # the button that lowers the octave of the sound track
        o2_method_new((full("/octaveDownTrackButton") + "/" + str(i)), "f",
                                    'octave_down_track_button_handler', true)
        # the slider that controls the volume of the track
        o2_method_new((full("/velocityTrackSlider") + "/" + str(i)), "i",
                                    'velocity_track_slider_handler', true)



def stop_all_button_handler(timestamp, address, types, val):
    choir.stop_all()

def start_all_button_handler(timestamp, address, types, val):
    choir.start_all()

def period_slider_handler(timestamp, address, types, val):
    choir.set_period()

def stop_track_handler(timestamp, address, types, val):
    # track_idx = (int)(val[0] - 1)
    track_idx = address[len(address) - 1]
    choir.tracks[track_idx].stop()

def start_track_handler(timestamp, address, types, val):
    # track_idx = (int)(val[0] - 1)
    track_idx = address[len(address) - 1]
    choir.tracks[track_idx].start()

def octave_up_track_button_handler(timestamp, address, types, val):
    # track_idx = (int)(val[0] - 1)
    track_idx = address[len(address) - 1]
    choir.tracks[track_idx].octave_up()

def octave_down_track_button_handler(timestamp, address, types, val):
    # track_idx = (int)(val[0] - 1)
    track_idx = address[len(address) - 1]
    choir.tracks[track_idx].octave_down()

def velocity_track_slider_handler(timestamp, address, types, val):
    # track_idx = (int)(val[0] - 1)
    track_idx = address[len(address) - 1]
    choir.tracks[track_idx].set_velocity(int(val))




def install_donttouchosc_handlers():
    print "Installing handlers for donttouchosc.srp messages"
    o2_method_new(full("/cmsip/buttonA"), "f", 'buttonA', true)
    o2_method_new(full("/cmsip/buttonB"), "f", 'buttonB', true)
    o2_method_new(full("/cmsip/buttonC"), "f", 'buttonC', true)
    o2_method_new(full("/cmsip/buttonD"), "f", 'buttonD', true)
    o2_method_new(full("/cmsip/sliderA"), "f", 'sliderA', true)
    o2_method_new(full("/cmsip/sliderB"), "f", 'sliderB', true)
    o2_method_new(full("/cmsip/sliderC"), "f", 'sliderC', true)
    o2_method_new(full("/cmsip/sliderD"), "f", 'sliderD', true)
    o2_method_new(full("/cmsip/checkW"), "f", 'checkW', true)
    o2_method_new(full("/cmsip/checkX"), "f", 'checkX', true)
    o2_method_new(full("/cmsip/checkY"), "f", 'checkY', true)
    o2_method_new(full("/cmsip/checkZ"), "f", 'checkZ', true)
    o2_method_new(full("/cmsip/canvas"), "fff", 'canvas', true)

# handler functions for donttouchosc messages
def buttonA(timestamp, address, types, val):
    display "server button A", address, val
def buttonB(timestamp, address, types, val):
    display "server button B", address, val
def buttonC(timestamp, address, types, val):
    display "server button C", address, val    
def buttonD(timestamp, address, types, val):
    display "server button D", address, val
def sliderA(timestamp, address, types, val):
    display "server slider A", address, val
def sliderB(timestamp, address, types, val):
    display "server slider B", address, val
def sliderC(timestamp, address, types, val):
    display "server slider C", address, val    
def sliderD(timestamp, address, types, val):
    display "server slider D", address, val
def checkW(timestamp, address, types, val):
    display "server checkbox W", address, val
def checkX(timestamp, address, types, val):
    display "server checkbox X", address, val
def checkY(timestamp, address, types, val):
    display "server checkbox Y", address, val
def checkZ(timestamp, address, types, val):
    display "server checkbox Z", address, val
def canvas(timestamp, address, types, x, y, status):
    display "server canvas", address, x, y, status




def open_port():

    # use the input port number if given
    if len(command_line_arguments) > 1 and isdigit(command_line_arguments[1])
        osc_port = int(command_line_arguments[1])

    rslt = o2_osc_port_new(SERVICE, osc_port, false)
    # an error occurred
    if rslt != 0
        display "in osc monitor, o2_osc_port_new returned ERROR", rslt
    else
        print "Listening on port ", osc_port

def runit():
    while true
        o2_poll()
        time_sleep(0.01)

def main():

    
    o2_initialize(APPLICATION, false)
    o2_service_new(SERVICE)
    # o2_debug_flags("O")
    o2_clock_set()
    open_port()
    install_handlers()
    install_donttouchosc_handlers()
    sched_o2_enabled = true
    # runit()


    # initialize the scheduler
    sched_init()

    # open midi output
    prefs = Prefs("./prefs.txt")
    midi_devices = Midi_devices(prefs, open_later = true)
    success = midi_devices.open_midi(latency = 10, device = 'midi_out_device')

    # check output device
    if not success
        print "PLEASE SELECT A VALID OUTPUT DEVICE AND RESTART THIS PROGRAM"
        return

    # sets the frame
    default_window.set_size(window_width, window_height)

    # initializes the music
    choir = Choir()
    # initializes the canvas
    p2Canvas = MusicCanvas(default_window, canvas_margin, canvas_margin,
                            canvas_width, canvas_height)
    p2Canvas.take_plugin(choir)

    sched_select(vtsched)
    sched_set_period(init_period)
    # starts the music
    sched_cause(real_delay(5),
                choir.track_one, 'play', 0, choir.track_one.curr_pitch)
    sched_cause(real_delay(5),
                choir.track_two, 'play', 0, choir.track_two.curr_pitch)
    sched_cause(real_delay(5),
                choir.track_three, 'play', 0, choir.track_three.curr_pitch)
    sched_cause(real_delay(5),
                choir.track_four, 'play', 0, choir.track_four.curr_pitch)
    # starts the animation
    sched_cause(real_delay(5), p2Canvas, 'animate')



main()
